use std::ops::Deref;

use ark_ed25519::Fr as ScalarField;
use ark_ff::{AdditiveGroup, Field};
use ark_serialize::CanonicalSerialize;

/// Serializes a `ScalarField` secret into a `ScalarField` nonce by concatenating the serialized
/// `secret` to randomly generated bytes of length 32.
/// Inputs:
///     - secret, a Scalar.
///
///Outputs:
///     - nonce, a Scalar.
///
///def nonce_generate(secret):
///  random_bytes = random_bytes(32)
///  secret_enc = G.SerializeScalar(secret)
///  return H3(random_bytes || secret_enc)
fn nonce_generate(_secret: ScalarField) -> ScalarField {
    unimplemented!();
}

#[derive(Clone, Copy, PartialEq, Eq)]
struct NonZeroScalar(ScalarField);

type NonceCommitment = ark_ed25519::EdwardsProjective;

type BindingFactor = (NonZeroScalar, ScalarField);

/// A Commitment is a tuple of (NonZeroScalar, NonceCommitment, NonceCommitment)
type Commitment = (NonZeroScalar, NonceCommitment, NonceCommitment);

impl NonZeroScalar {
    pub fn new(value: ScalarField) -> Self {
        if value == ScalarField::ZERO {
            panic!("NonZeroScalar cannot be zero")
        }

        NonZeroScalar(value)
    }
}

/// Derives and returns a value used for polynomial interpolation.
///
/// # Panics
///
/// Panics if `x_coordinates` do not contain `x_i`, or if `x_i` is found more than once in
/// `x_coordinates`.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.2
fn derive_interpolating_value(x_coordinates: &[NonZeroScalar], x_i: NonZeroScalar) -> ScalarField {
    if !x_coordinates.contains(&x_i) {
        panic!("Invalid parameters")
    };

    if x_coordinates.iter().filter_map(|x| Some(x == &x_i)).count() > 1 {
        panic!("Invalid parameters")
    }

    let mut numerator = ScalarField::ONE;
    let mut denominator = ScalarField::ONE;

    for x_j in x_coordinates {
        if x_j == &x_i {
            continue;
        }
        numerator *= x_j.0;
        denominator *= x_j.0 - x_i.0;
    }

    return numerator / denominator;
}

/// Encodes and returns a list of participant `Commitment`s into a byte string for use in the FROST
/// protocol.
///
/// # Panics
///
/// Panics if serialization fails.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.3
fn encode_group_commitment_list(commitment_list: &[Commitment]) -> Vec<u8> {
    let mut encoded = vec![];

    for (identifier, hiding_nonce_commitment, binding_nonce_commitment) in commitment_list {
        let mut identifier_bytes = Vec::new();
        let mut hiding_nonce_commitment_bytes = Vec::new();
        let mut binding_nonce_commitment_bytes = Vec::new();

        identifier
            .0
            .serialize_compressed(&mut identifier_bytes)
            .unwrap();

        hiding_nonce_commitment
            .serialize_compressed(&mut hiding_nonce_commitment_bytes)
            .unwrap();
        binding_nonce_commitment
            .serialize_compressed(&mut binding_nonce_commitment_bytes)
            .unwrap();

        let mut encoded_commitment = [
            identifier_bytes,
            hiding_nonce_commitment_bytes,
            binding_nonce_commitment_bytes,
        ]
        .concat();

        encoded.append(&mut encoded_commitment);
    }

    return encoded;
}

/// Extracts and returns a list of identifiers `Vec<NonZeroScalar>` from a `commitment list`.
fn participants_from_commitment_list(commitment_list: &[Commitment]) -> Vec<NonZeroScalar> {
    let mut identifiers: Vec<NonZeroScalar> = Vec::with_capacity(commitment_list.len());
    for (i, _, _) in commitment_list.iter() {
        identifiers.push(*i);
    }

    return identifiers;
}

/// Extracts and returns a `BindingFactor` from a `Vec<BindingFactor>` given a `NonZeroScalar`
/// identifier.
fn binding_factor_for_participant(
    binding_factor_list: Vec<BindingFactor>,
    identifier: NonZeroScalar,
) -> ScalarField {
    return binding_factor_list
        .iter()
        .find(|(id, bf)| *id == identifier)
        .unwrap()
        .1;
}
