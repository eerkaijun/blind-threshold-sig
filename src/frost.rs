use ark_ed25519::Fr as ScalarField;
use ark_ff::{AdditiveGroup, Field};

/// Serializes a `ScalarField` secret into a `ScalarField` nonce by concatenating the serialized
/// `secret` to randomly generated bytes of length 32.
/// Inputs:
///     - secret, a Scalar.
///
///Outputs:
///     - nonce, a Scalar.
///
///def nonce_generate(secret):
///  random_bytes = random_bytes(32)
///  secret_enc = G.SerializeScalar(secret)
///  return H3(random_bytes || secret_enc)
fn nonce_generate(_secret: ScalarField) -> ScalarField {
    unimplemented!();
}

#[derive(PartialEq, Eq)]
struct NonZeroScalar(ScalarField);

impl NonZeroScalar {
    pub fn new(value: ScalarField) -> Self {
        if value == ScalarField::ZERO {
            panic!("NonZeroScalar cannot be zero")
        }

        NonZeroScalar(value)
    }
}

/// Derives and returns a value used for polynomial interpolation.
///
/// # Panics
///
/// Panics if `x_coordinates` do not contain `x_i`, or if `x_i` is found more than once in
/// `x_coordinates`.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.2
fn derive_interpolating_value(x_coordinates: &[NonZeroScalar], x_i: NonZeroScalar) -> ScalarField {
    if !x_coordinates.contains(&x_i) {
        panic!("Invalid parameters")
    };

    if x_coordinates.iter().filter_map(|x| Some(x == &x_i)).count() > 1 {
        panic!("Invalid parameters")
    }

    let mut numerator = ScalarField::ONE;
    let mut denominator = ScalarField::ONE;

    for x_j in x_coordinates {
        if x_j == &x_i {
            continue;
        }
        numerator *= x_j.0;
        denominator *= x_j.0 - x_i.0;
    }

    return numerator / denominator;
}
