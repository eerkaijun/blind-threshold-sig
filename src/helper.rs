use ark_ec::{AdditiveGroup, PrimeGroup};
use ark_ed25519::{EdwardsProjective as Element, Fr as ScalarField};
use ark_ff::{Field, PrimeField};
use ark_serialize::CanonicalSerialize;

use crate::ciphersuite::{H1, H2, H4, H5};

/// Serializes a `ScalarField` secret into a `ScalarField` nonce by concatenating the serialized
/// `secret` to randomly generated bytes of length 32.
/// Inputs:
///     - secret, a Scalar.
///
///Outputs:
///     - nonce, a Scalar.
///
///def nonce_generate(secret):
///  random_bytes = random_bytes(32)
///  secret_enc = G.SerializeScalar(secret)
///  return H3(random_bytes || secret_enc)
pub fn nonce_generate(_secret: ScalarField) -> ScalarField {
    unimplemented!();
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub struct NonZeroScalar(ScalarField);

type NonceCommitment = Element;

pub type BindingFactor = (NonZeroScalar, ScalarField);

/// A Commitment is a tuple of (NonZeroScalar, NonceCommitment, NonceCommitment)
pub type Commitment = (NonZeroScalar, NonceCommitment, NonceCommitment);

impl NonZeroScalar {
    pub fn new(value: ScalarField) -> Self {
        if value == ScalarField::ZERO {
            panic!("NonZeroScalar cannot be zero")
        }

        NonZeroScalar(value)
    }
}

/// Derives and returns a value used for polynomial interpolation.
///
/// # Panics
///
/// Panics if `x_coordinates` do not contain `x_i`, or if `x_i` is found more than once in
/// `x_coordinates`.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.2
pub fn derive_interpolating_value(
    x_coordinates: &[NonZeroScalar],
    x_i: NonZeroScalar,
) -> ScalarField {
    if !x_coordinates.contains(&x_i) {
        panic!("Invalid parameters")
    };

    if x_coordinates.iter().filter_map(|x| Some(x == &x_i)).count() > 1 {
        panic!("Invalid parameters")
    }

    let mut numerator = ScalarField::ONE;
    let mut denominator = ScalarField::ONE;

    for x_j in x_coordinates {
        if x_j == &x_i {
            continue;
        }
        numerator *= x_j.0;
        denominator *= x_j.0 - x_i.0;
    }

    return numerator / denominator;
}

/// Encodes and returns a list of participant `Commitment`s into a byte string for use in the FROST
/// protocol.
///
/// # Panics
///
/// Panics if serialization fails.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.3
pub fn encode_group_commitment_list(commitment_list: &[Commitment]) -> Vec<u8> {
    let mut encoded = vec![];

    for (identifier, hiding_nonce_commitment, binding_nonce_commitment) in commitment_list {
        let mut identifier_bytes = Vec::new();
        let mut hiding_nonce_commitment_bytes = Vec::new();
        let mut binding_nonce_commitment_bytes = Vec::new();

        identifier
            .0
            .serialize_compressed(&mut identifier_bytes)
            .unwrap();

        hiding_nonce_commitment
            .serialize_compressed(&mut hiding_nonce_commitment_bytes)
            .unwrap();
        binding_nonce_commitment
            .serialize_compressed(&mut binding_nonce_commitment_bytes)
            .unwrap();

        let mut encoded_commitment = [
            identifier_bytes,
            hiding_nonce_commitment_bytes,
            binding_nonce_commitment_bytes,
        ]
        .concat();

        encoded.append(&mut encoded_commitment);
    }

    return encoded;
}

/// Extracts and returns a list of identifiers `Vec<NonZeroScalar>` from a `commitment list`.
pub fn participants_from_commitment_list(commitment_list: &[Commitment]) -> Vec<NonZeroScalar> {
    let mut identifiers: Vec<NonZeroScalar> = Vec::with_capacity(commitment_list.len());
    for (i, _, _) in commitment_list.iter() {
        identifiers.push(*i);
    }

    return identifiers;
}

/// Extracts and returns a `BindingFactor` from a `Vec<BindingFactor>` given a `NonZeroScalar`
/// identifier.
pub fn binding_factor_for_participant(
    binding_factor_list: &[BindingFactor],
    identifier: NonZeroScalar,
) -> ScalarField {
    return binding_factor_list
        .iter()
        .find(|(id, _)| *id == identifier)
        .unwrap()
        .1;
}

/// Computes and returns `Vec<BindingFactor>` based on participant `commitment_list`, `msg` and
/// the group public key `group_pk`.
///
/// Reference: https://www.rfc-editor.org/rfc/rfc9591.html#section-4.4
pub fn compute_binding_factors(
    group_pk: Element,
    commitment_list: &[Commitment],
    msg: Vec<u8>,
) -> Vec<BindingFactor> {
    let mut group_pk_encoded = vec![];
    group_pk
        .serialize_compressed(&mut group_pk_encoded)
        .unwrap();

    let msg_hash = H4(msg);
    let encoded_commitment_hash = H5(encode_group_commitment_list(commitment_list));

    let rho_input_prefix: Vec<u8> = [group_pk_encoded, msg_hash, encoded_commitment_hash].concat();

    let mut binding_factor_list = Vec::with_capacity(commitment_list.len());

    for (identifier, _, _) in commitment_list {
        let mut identifier_bytes = Vec::new();
        identifier
            .0
            .serialize_compressed(&mut identifier_bytes)
            .unwrap();

        let rho_input = [rho_input_prefix.clone(), identifier_bytes].concat();
        let binding_factor = ScalarField::from_le_bytes_mod_order(&H1(rho_input));

        binding_factor_list.push((*identifier, binding_factor));
    }

    return binding_factor_list;
}

pub fn compute_group_commitment(
    commitment_list: &[Commitment],
    binding_factor_list: Vec<BindingFactor>,
) -> Element {
    // TODO: fix
    let mut group_commitment = Element::ZERO;

    for (identifier, hiding_nonce_commitment, binding_nonce_commitment) in commitment_list {
        let binding_factor = binding_factor_for_participant(&binding_factor_list, *identifier);
        let binding_nonce = *binding_nonce_commitment * binding_factor;

        group_commitment += hiding_nonce_commitment + binding_nonce;
    }

    return group_commitment;
}

pub fn compute_challenge(group_commitment: Element, group_pk: Element, msg: Vec<u8>) -> Vec<u8> {
    let mut group_commitment_encoded_bytes = Vec::new();
    let mut group_pk_encoded_bytes = Vec::new();

    group_commitment
        .serialize_compressed(&mut group_commitment_encoded_bytes)
        .unwrap();
    group_pk
        .serialize_compressed(&mut group_pk_encoded_bytes)
        .unwrap();
    let challenge_input = [group_commitment_encoded_bytes, group_pk_encoded_bytes, msg].concat();
    let challenge = H2(challenge_input);

    return challenge;
}
